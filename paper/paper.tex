\documentclass[9pt]{entcs}

\usepackage{cleveref}
\usepackage{entcsmacro}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{bussproofs}
\usepackage{stmaryrd}
\usepackage{cleveref}
\usepackage{listings}
\usepackage{coq}
\usepackage{color}
\usepackage{xcolor}

\sloppy
% The following is enclosed to allow easy detection of differences in
% ascii coding.
% Upper-case    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
% Lower-case    a b c d e f g h i j k l m n o p q r s t u v w x y z
% Digits        0 1 2 3 4 5 6 7 8 9
% Exclamation   !           Double quote "          Hash (number) #
% Dollar        $           Percent      %          Ampersand     &
% Acute accent  '           Left paren   (          Right paren   )
% Asterisk      *           Plus         +          Comma         ,
% Minus         -           Point        .          Solidus       /
% Colon         :           Semicolon    ;          Less than     <
% Equals        =3D           Greater than >          Question mark ?
% At            @           Left bracket [          Backslash     \
% Right bracket ]           Circumflex   ^          Underscore    _
% Grave accent  `           Left brace   {          Vertical bar  |
% Right brace   }           Tilde        ~


\newenvironment{bprooftree}
{\leavevmode\hbox\bgroup}
{\DisplayProof\egroup}

\crefname{lemma}{lemma}{lemmata}
\Crefname{lemma}{lemma}{lemmata}

\newtheorem{notation}[thm]{Notation}

\newcommand{\ie}{\emph{i.e.,} }
\newcommand{\cf}{\emph{c.f.} }
\newcommand{\eg}{\emph{e.g.,} }
\newcommand{\etal}{\emph{et~al.}}
\newcommand{\etc}{\emph{etc.}}
\newcommand{\wrt}{w.r.t.~}
\newcommand{\resp}{resp.~}
\newcommand{\loccit}{\emph{loc. cit.} }

% Setting modes
\newcommand{\type}[1]{\textsc{#1}}
\newcommand{\term}[1]{\mathsf{#1}}
\newcommand{\constructor}[1]{\mathbf{#1}}
\newcommand{\category}[1]{\textsc{#1}}
\newcommand{\functortxt}[1]{\mathsf{#1}}
\newcommand{\nattranstxt}[1]{\mathsf{#1}}
\newcommand{\function}[1]{\mathsf{#1}}
\newcommand{\morphism}[1]{\mathsf{#1}}

% HoTT
\newcommand{\deprod}[3]{\prod(#1 : #2), #3} % dependent product
%\newcommand{\deprod}[3]{\prod_{#1 : #2} #3} % dependent product
\newcommand{\desum}[3]{\sum(#1 : #2), #3} % dependent sum
%\newcommand{\desum}[3]{\sum_{#1 : #2} #3} % dependent sum
\newcommand{\hset}{\type{hSet}} % sets
\newcommand{\0}{\textbf{0}} % empty type
\newcommand{\1}{\textbf{1}} % unit type
\newcommand{\TT}{\constructor{tt}} % element of unit type
\newcommand{\inl}{\term{inl}} %left inclusion
\newcommand{\inr}{\term{inr}} % right inclusion
\newcommand{\prl}{\term{pr}_1} % first projection
\newcommand{\prr}{\term{pr}_2} % second projection
\newcommand{\pairTm}[2]{(#1 , #2)} % pairing
\newcommand{\weq}{\simeq} % equivalence
\newcommand{\setquot}[2]{#1 / #2} % quotient type
\newcommand{\transport}[2]{\function{transport}^{#1} \> #2} % transport
\newcommand{\invP}[1]{(#1)^{-1}} % inverse of a path
\newcommand{\classof}{\constructor{class}} % class construcor
\newcommand{\classeq}{\constructor{classeq}} % path between classes
\newcommand{\isaprop}[1]{\function{isaprop}(#1)} % a type is a set
\newcommand{\isaset}[1]{\function{isaset}(#1)} % a type is a set
\newcommand{\trunct}[1]{\lVert #1 \rVert} % propositional truncation
\newcommand{\truncel}[1]{| #1 |} % constructor of truncation
\newcommand{\depeq}[3]{#2 =_{#1} #3} % dependent equality type
\newcommand{\Def}{:=} % symbol for definition

% Category theory
\newcommand{\idm}[1]{\morphism{id}_{#1}} % identity morphism
\newcommand{\compm}[2]{#2 \circ #1} % composition of morphisms
\newcommand{\iso}[2]{#1 \cong #2} % isomorphisms
\newcommand{\setoids}{\category{Setoid}} % category of setoids
\newcommand{\functor}[2]{#1 \longrightarrow #2} % functors
\newcommand{\idf}[1]{\functortxt{id}_{#1}} % identity functor
\newcommand{\Cf}[1]{\functortxt{C}_{#1}} % constant functor
\newcommand{\compf}[2]{#2 \circ #1} % composition of functors
\newcommand{\prodf}[2]{#1 \times #2} % product of functors
\newcommand{\sumf}[2]{#1 + #2} % sum of functors
\newcommand{\nattrans}[2]{#1 \Longrightarrow #2} % natural transfomations
\newcommand{\ctrans}[1]{\nattranstxt{c}_{#1}} % constant transformation
\newcommand{\constrt}[1]{\nattranstxt{constr}_{#1}} % constructor transformation
\newcommand{\idt}[1]{\nattranstxt{id}} % identity transformation
\newcommand{\compt}[2]{#2 \circ #1} % composition of natural transformations
\newcommand{\lwhisker}[2]{#2 \vartriangleright #1} % whiskering of transformations
\newcommand{\inlt}{\nattranstxt{inl}} %left inclusion of transformations
\newcommand{\inrt}{\nattranstxt{inr}} % right inclusion of transformations
\newcommand{\prlt}{\nattranstxt{pr}_1} % first projection of transformations
\newcommand{\prrt}{\nattranstxt{pr}_2} % second projection of transformations
\newcommand{\pairt}[2]{(#1 , #2)} % pairing of transformations
\newcommand{\idtoiso}{\function{idtoiso}} % identity to iso
\newcommand{\falg}[1]{\category{FAlg}(#1)} % category of algebras on a functor
\newcommand{\adj}[2]{#1 \dashv #2} % adjunction
\newcommand{\fullsub}[2]{\function{full}(#1,#2)} % full subcategory
\newcommand{\factorsub}[1]{#1_{\function{sub}}} % factor through full sub

% Polynomials
\newcommand{\poly}{\mathcal{P}} % type of polynomials
\newcommand{\C}{\constructor{C}} % constant polynomial
\newcommand{\I}{\constructor{I}} % identity polynomial
\newcommand{\sumP}[2]{#1 + #2} % sum of polynomials
\newcommand{\prodP}[2]{#1 \times #2} % product of polynomials

% Equivalence relations
\newcommand{\pathR}[1]{\function{Path} \> #1} % path equivalence relation
\newcommand{\sumR}[2]{#1 + #2} % sum of equivalence relations
\newcommand{\prodR}[2]{#1 \times #2} % product of equivalence relations
\newcommand{\polyR}[2]{\widehat{#1} \> #2} % action of polynomials on equivalence relations

% Endpoints
\newcommand{\ep}[3]{\mathcal{E}_{#1}(#2,#3)} % type of endpoinst
\newcommand{\id}[1]{\constructor{id}_{#1}} % identity endpoints
\newcommand{\comp}[2]{#1 \cdot #2} % composition of endpoints
\newcommand{\inle}{\constructor{inl}} %left inclusion of endpoints
\newcommand{\inre}{\constructor{inr}} % right inclusion of endpoints
\newcommand{\prle}{\constructor{pr}_1} % first projection of endpoints
\newcommand{\prre}{\constructor{pr}_2} % second projection of endpoints
\newcommand{\pair}[2]{(#1 , #2)} % pairing of endpoints
\newcommand{\Ce}{\constructor{c}} % constant endpoint
\newcommand{\constr}{\constructor{constr}} % constructor endpoint

% Signatures
\newcommand{\pt}[0]{\textsf{pt}}
\newcommand{\pthI}[0]{\textsf{pth}}
\newcommand{\pthA}[0]{\textsf{arg}}
\newcommand{\pthlh}[0]{\textsf{lhs}}
\newcommand{\pthrh}[0]{\textsf{rhs}}
\newcommand{\pointc}[1]{#1_{\pt}} % point constructor
\newcommand{\pathI}[1]{#1_{\pthI}} % path constructor index
\newcommand{\pathA}[1]{#1_{\pthA}} % path constructor index
\newcommand{\pathlh}[1]{#1_{\pthlh}} % left endpoint of path constructor
\newcommand{\pathrh}[1]{#1_{\pthrh}} % left endpoint of path constructor

\newcommand{\comm}{\function{comm}} % remove
\newcommand{\modsig}{\function{mod}} % signature for integers mod 2
\newcommand{\trunc}{\function{trunc}} % signature for truncation
\newcommand{\sig}{\mathcal{S}} % variable for signatures

% Algebras
\newcommand{\semP}[1]{\llbracket #1 \rrbracket} % semantics of polynomials
\newcommand{\prealg}[1]{\category{PreAlg}_{\hset}(#1)} % category of prealgebras
\newcommand{\forget}[1]{\mathcal{F}_{#1}} % forgetful functor
\newcommand{\semE}[1]{\llbracket #1 \rrbracket} % semantics of endpoints

\newcommand{\Alg}[1]{\category{Alg}_{\hset}(#1)} % category of algebras
\newcommand{\constrA}[1]{\function{map}_{#1}} % point constructor of algebra
\newcommand{\constrP}[1]{\function{path}_{#1}} % path constructor of algebra

% Algebras in setoids
\newcommand{\semPT}[1]{\langle #1 \rangle} % semantics of polynomials in setoids
\newcommand{\semET}[1]{\langle #1 \rangle} % semantics of endpoints in setoids
\newcommand{\prealgst}[1]{\category{PreAlg}_{\setoids}(#1)} % category of setoid prealgebras
\newcommand{\Algst}[1]{\category{Alg}_{\setoids}(#1)} % category of algebras in setoids

% Displayed algebras
\newcommand{\polydact}[2]{\overline{#1} \> #2} % dependent action of polynomials on families
\newcommand{\epdact}[2]{\overline{#1} \> #2} % dependent action of endpoints
\newcommand{\polydmap}[2]{\overline{#1} \> #2} % action of polynomials on dependent maps
\newcommand{\total}[1]{\int #1} % total algebra of displayed algebra
\newcommand{\proj}[1]{\pi_1^{#1}} % projection homomorphism
\newcommand{\Ppl}[1]{\pi_1^{#1}} % dependent second projection, poly_pr2
\newcommand{\Ppr}[1]{\pi_2^{#1}} % dependent second projection, poly_pr2
\newcommand{\Epl}{\function{epr_1}} % first projection of endpoint action
\newcommand{\Epr}{\function{epr_2}} % first projection of endpoint action
\newcommand{\constdisp}{\function{const}} % constant displayed algebra

% Examples of HITs
\newcommand{\Circ}{S^1} % circle
\newcommand{\base}{\constructor{base}} % base point of circle
\newcommand{\loopS}{\constructor{loop}} % base point of circle
\newcommand{\modZ}{\mathbb{Z}_2} % integers modulo 2
\newcommand{\ZZ}{\constructor{Z}} % zero
\newcommand{\SZ}{\constructor{S}} % successor
\newcommand{\modP}{\constructor{mod}} % n = n + 2
\newcommand{\HIT}{\function{HIT}} % the HIT of a signature

% Adjunction
\newcommand{\quotF}{\mathcal{Q}}
\newcommand{\pathF}{\pi_0}
\newcommand{\quotPA}{\mathcal{Q}^{\category{PreAlg}}}
\newcommand{\pathPA}{\pi^{\category{PreAlg}_0}}
\newcommand{\quotAA}{\mathcal{Q}^{\category{Alg}}}
\newcommand{\pathAA}{\pi_0^{\category{Alg}}}

% Free congruence
\newcommand{\CRC}{\mathcal{X}} % carrier
\newcommand{\CR}{\mathcal{R}^*} % relation
\newcommand{\CRR}{\mathcal{R}} % relation
\newcommand{\CRrefl}{\constructor{refl}} % reflexivity
\newcommand{\CRsym}{\constructor{sym}} % symmetry
\newcommand{\CRtrans}{\constructor{trans}} % transitivity
\newcommand{\CRpair}{\constructor{pair}} % pair
\newcommand{\CRinl}{\constructor{inl}} % in left
\newcommand{\CRinr}{\constructor{inr}} % in right
\newcommand{\CRpath}{\constructor{path}} % path constuctors
\newcommand{\CRcong}{\constructor{cong}} % congruence

\newcommand{\remove}{} % remove a part

\def\lastname{Van der Weide}
\begin{document}
\begin{frontmatter}
  \title{The Construction of Set-Truncated Higher Inductive Types} \author{Niels van der Weide
    \thanksref{ALL}\thanksref{myemail}}
  \address{Institute for Computation and Information Sciences\\ Radboud Universiteit\\
    Nijmegen, The Netherlands} \author{My Co-author\thanksref{coemail}}
  \address{My Co-author's Department\\My Co-author's University\\
    My Co-author's City, My Co-author's Country} \thanks[ALL]{We would like to thank Dan Frumin and Andrej Bauer for inspiring discussions. Work on this article was supported by a grant from the \href{https://eutypes.cs.ru.nl/}{COST Action EUTypes CA15123}.} \thanks[myemail]{Email:
    \href{mailto:nweide@cs.ru.nl} {\texttt{\normalshape
        nweide@cs.ru.nl}}} \thanks[coemail]{Email:
    \href{mailto:couserid@codept.coinst.coedu} {\texttt{\normalshape
        couserid@codept.coinst.coedu}}}
\begin{abstract} 
  We construct finitary set-truncated higher inductive types (HITs) using quotients and the propositional truncation.
  Using a modification of the schema by Basold \etal, we define a notion of signatures and univalent categories of algebras in both sets and setoids.
  To interpret HITs, we use initial algebra semantics for which we show that the initiality implies induction.
  The desired algebra is obtained by lifting the quotient adjunction to the level of algebras and adapting Dybjer's and Moeneclaey's interpretation of HITs in setoids.
  From this construction, we conclude that the equality types of HITs are freely generated and that HITs are unique.
  The results are formalized in the UniMath library.
\end{abstract}
\begin{keyword}
higher inductive types, homotopy type theory, category theory, setoids, intuitionistic type theory, Coq
\end{keyword}
\end{frontmatter}
\section{Introduction}
\label{intro}
Homotopy type theory (HoTT) is a form of intensional type theory. 
It has semantics in the simplicial sets model \cite{simpset}, and types represent spaces, terms represent points, and equalities represent paths.
Furthermore, equality is proof relevant and we frequently talk about homotopies: paths between paths.

One of the main features of HoTT, is higher inductive types (HITs) \cite{hottbook}.
These are types generated by constructors for their points, paths, homotopies, and so on.
HITs have been used in numerous applications among which are homotopical patch theory \cite{AngiuliMLH16}. synthetic homotopy theory \cite{LicataF14,LicataS13,hottbook}, defining type theory within type theory \cite{AltenkirchK16}, constructive finiteness \cite{FruminGGW18}, and the partiality monad \cite{AltenkirchDK17}.
To get a feeling for what HITs are, let us look a some examples.

\lstset{language=Coq}
\setlength{\tabcolsep}{30pt}	
\begin{tabular}{ c c c }

\begin{lstlisting}[mathescape=true]
Inductive $\Circ$ :=
| $\base$ : $\Circ$
| $\loopS$ : $\base = \base$
\end{lstlisting}
&
\begin{lstlisting}[mathescape=true]
Inductive $\trunct{A}$ :=
| $\truncel{\cdot}$ : $A \rightarrow \trunct{A}$
| $p$ : $\deprod{x, y}{\trunct{A}}{x = y}$
\end{lstlisting}
&
\begin{lstlisting}[mathescape=true]
Inductive $\modZ$ :=
| $\ZZ$ : $\modZ \rightarrow \modZ$
| $\SZ$ : $\modZ \rightarrow \modZ$
| $\modP$ : $\deprod{x}{\modZ}{\SZ(\SZ \> x) = x}$
\end{lstlisting}
\end{tabular}

The first one, $\Circ$, is the \emph{circle}.
It has a point $\base$ and a path $\loopS : \base = \base$.
Since neither the point nor path constructors uses arguments from $\Circ$, this HIT is \emph{nonrecursive}.
The second, $\trunct{A}$, is the \emph{propositional truncation} of $A$.
This type is $A$ with all its points identified.
Note that the path constructor $p$ uses arguments from $\trunct{A}$, which means this HIT is \emph{recursive}.
The last one, $\modZ$, is the \emph{integers modulo 2} and note that both the point constructor $\SZ$ and path constructor $\modP$ are recursive.

HITs have been studied formally and several schemes have already been developed.
Awodey \etal \ showed that the rules of inductive types \cite{dybjer1994inductive} in HoTT are equivalent to being a homotopy initial algebra \cite{AwodeyGS12}.
They extended this result to a class of HITs called \emph{W-suspensions} \cite{Sojakova15}.
Another scheme, quotient inductive-inductive types (QIITs), was defined semantically by Altenkirch \etal \ and they show initial algebras are QIITs \cite{AltenkirchCDKF18}.
Assuming UIP, Kaposi \etal \ constructed finitary QIITs as the syntax of a domain specific type theory \cite{KaposiKA19}, and they extended this scheme to higher inductive-inductive types \cite{KaposiK18}.
Basold \etal \ defined an external syntactic scheme for HITs with only point and path constructors \cite{BasoldGW17}
while Dybjer and Moenclaey defined a scheme allowing constructors for points, paths, and homotopies, and they give its interpretation in the groupoid model  \cite{DybjerM18,HofmannS94}.
Cavallo and Harper extend computational cubical type theory with a scheme for indexed cubical inductive types and proved canonicity \cite{AngiuliHW17,CavalloH19}.

Furthermore, the semantics of HITs also has been studied.
Coquand \etal \ provide the semantics of various higher inductive types, such as spheres, the torus, the truncation, and the pushout, in cubical type theory \cite{BezemCH13,CohenCHM16,CoquandHM18}.
On the other hand, Lumsdaine and Shulman also study the semantics of higher inductive types using a semantic scheme (cell monads with parameters) and they prove existence in sufficiently nice Quillen model categories \cite{lumsdaine2017semantics}.
Some recursive higher inductive types can be constructed from nonrecursive HITs.
Both Kraus and Van Doorn show that the propositional truncation can be constructed from non-recursive HITs \cite{Kraus16,Doorn16} and Rijke shows that every truncation can be constructed via non-recursive HITs \cite{rijke2017join}.

In this paper, we show that all finitary set-truncated HITs can be constructed with quotients and propositional truncations. 
This briefly means that all higher inductive types exist if a small number of simple ones exist.
A similar result was obtained by Kaposi \etal \ \cite{KaposiKA19}, but we do not assume UIP and we use simpler HITs for the construction.
Furthermore, we use this construction to deduce several properties of HITs such as uniqueness and that the path space is freely generated.
Kraus and Von Raumer obtained an analogous result for the coequalizer by providing a nicer induction principle for its path types \cite{KrausRaumer}.
Note that from our construction we can conclude that all finitary set-truncated HITs can be constructed from non-recursive HITs.
Since quotients can be constructed from coequalizers and set truncations, we only need coequalizers and propositional/set truncations for this construction \cite{rijke2017join}.

The main idea of the proof is to take advantage that the quotient is left adjoint functor from setoids to sets \cite{RijkeS15}.
To relate this to HITs, we first define schemes, which are an internalized version of the schema by Basold \etal \ \cite{BasoldGW17}, and categories of algebras on them.
Then we lift the quotient adjunction to an adjunction from algebras in setoids and algebras in sets.
Since initiality implies induction, it suffices to construct the initial setoid algebra for which we adapt the construction by Dybjer and Moenclaey \cite{moeneclaey2016schema,DybjerM18}.

All definitions and proofs in his paper are formalized over the UniMath library \cite{UniMath}.
The formalization is 4166 lines of code and it can be found on \url{https://github.com/nmvdw/SetHITs}.

We start in \Cref{sec:prelim} by recalling some definitions from HoTT and category theory required for the rest of the paper.
In \Cref{sec:signature}, we define signatures for higher inductive types and give a couple of examples.
Next we define algebras in both the categories of sets and setoids for such signatures in \Cref{sec:algebras}.
We define the induction principle of HITs via displayed algebras in \Cref{sec:induction} and we show that initial objects satisfy this principle.
\Cref{sec:construction} is the core of this paper and there we construct an adjunction between algebras in sets and setoids, which we use to construct the initial algebra in sets via the initial algebra in setoids.
We study the consequences of this construction in \Cref{sec:consequences} and in \Cref{sec:conclusion}, we conclude and discuss further work.

\section{Preliminaries}
\label{sec:prelim}
We start by recalling some definitions and notations from homotopy type theory and category theory \cite{mac2013categories,hottbook}.
The first notion we need, is the \emph{dependent equality type}.

\begin{definition}
\label{def:depeq}
Given a type $X$, inhabitants $x, y : X$, a type family $Y$ on $X$, and a path $p : x = y$, we define
\[
\transport{Y}{p} : Y \> x \rightarrow Y \> y.
\]
Given a path $p : x = y$ and inhabitants $z_1 : Y \> x$ and $z_2 : Y \> y$, we write $\depeq{p}{z_1}{z_2}$ for $\transport{Y}{p} \ z_1 = z_2$.
\end{definition}

One of the core features of HoTT, is that equality is proof relevant.
This means that not all inhabitants of $x = y$ are necessarily equal.
Some types might actually have proof irrelevant equality, and we call such types \emph{sets}.
More precisely, we define

\begin{definition}
\label{def:prop}
\label{def:set}
A type $X$ is a \emph{(mere) proposition} if for all $x, y : X$ we have $x = y$.
A type $X$ is a \emph{set} if for all $x, y : X$ the type $x = y$ is a proposition.
We write $\isaprop{X}$ and $\isaset{X}$ to say that $X$ is a proposition and set respectively.
\end{definition}

Our goal is to construct all higher inductive types from two specific ones, namely the \emph{quotient type} and the \emph{propositional truncation}.
We only give their introduction rules here, and for their elimination and computation rules, we refer the reader to the literature \cite{hottbook}.

\begin{definition}
\label{def:quot}
Let $X$ be a type and let $R$ be an equivalence relation on $X$.
The \emph{quotient type} $\setquot{X}{R}$ is the higher inductive type generated by
\begin{center}
\begin{bprooftree}
\AxiomC{$x : X$}
\UnaryInfC{$\classof \> x : \setquot{X}{R}$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$x, y : X$}
\AxiomC{$r : R \> x \> y$}
\BinaryInfC{$\classeq \> r : \classof \> x = \classof \> y$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$\isaset{\setquot{X}{R}}$}
\end{bprooftree}
\end{center}
\end{definition}

\begin{definition}
\label{def:trunc}
Let $X$ be a type.
The \emph{propositional truncation} $\trunct{X}$ is the higher inductive type generated by
\begin{center}
\begin{bprooftree}
\AxiomC{$x : X$}
\UnaryInfC{$\truncel{x} : \trunct{X}$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$\isaprop{\trunct{X}}$}
\end{bprooftree}
\end{center}
\end{definition}

Next we briefly discuss category theory in univalent foundations \cite{AhrensKS15,hottbook}.
We start by recalling the definition of categories.
This is almost the same as the usual definition in mathematics, but their is a slight discrepancy between the objects and arrows.
While the objects can be any type, the arrows have to form a set.
Proof relevant equality on arrows would induce the structure of a higher category instead of an ordinary one.
This leads to the following definition.

\begin{definition}
\label{def:cat}
A \emph{category} $\mathcal{C}$ consists of
\begin{itemize}
	\item a type $\mathcal{C}_0$ of objects;
	\item for each $X, Y : \mathcal{C}_0$ a set $\mathcal{C}_1(X,Y)$ of morphisms;
	\item for each $X : \mathcal{C}_0$ a morphisms $\idm{X}$;
	\item for all objects $X, Y, Z : \mathcal{C}_0$ and morphisms $f : \mathcal{C}_1(X,Y)$ and $g : \mathcal{C}_1(Y,Z)$, a morphism $\compm{f}{g} : \mathcal{C}_1(X,Z)$
\end{itemize}
such that the usual associativity and identity laws holds.
\end{definition}

We define isomorphisms in categories the usual way and we denote the type of isomorphisms from $X$ to $Y$ by $\iso{X}{Y}$.
In the remainder, we also make use of \emph{univalent categories}.
These are categories in which equality on objects is equivalent to isomorphisms between them.
For the definition of equivalence of equivalences, we refer the reader to the literature \cite{hottbook}.
More precisely, we define them as follows.

\begin{definition}
\label{def:univalent}
Let $\mathcal{C}$ be a category.
Note that for all objects $X$ and $Y$ we have a map $\idtoiso_{X,Y} : X = Y \rightarrow \iso{X}{Y}$ sending the reflexivity path to the identity isomorphism.
Then we say $\mathcal{C}$ is \emph{univalent} if $\idtoiso_{X,Y}$ is an equivalence for each $X$ and $Y$.
\end{definition}

The primary example of a univalent category is the category $\hset$ of sets and functions between them.
Another example of a univalent category which we use frequently, is the category of \emph{setoids}.

\begin{definition}
\label{def:setoid}
We define
\begin{itemize}
	\item A \emph{setoid} is a set $X$ together with an equivalence relation on $X$;
	\item A \emph{setoid morphism} between two setoids  is a map between the underlying sets which preserves the equivalence relation.
\end{itemize}
The \emph{category of setoids} $\setoids$ is the category with setoids and setoid morphisms as objects and morphisms.
\end{definition}

If $X$ is a set and $R$ is an equivalence relation on $X$, then we write $(X, R)$ for the setoid with this data.
When it is clear from the context, we write $\equiv$ for the relation.
We finish this section by giving some operations of functor and natural transformations, which we need later.
Functors and transformations are defined the usual way \cite{mac2013categories}, and we write $\functor{\mathcal{C}}{\mathcal{D}}$ and $\nattrans{F}{G}$ for the type of functors from $\mathcal{C}$ to $\mathcal{D}$ and natural transformations from $\mathcal{F}$ to $\mathcal{G}$ respectively.

\begin{notation}
\label{def:functor}
We have the following functors.
\begin{itemize}
	\item For each category $\mathcal{C}$, we have the identity $\idf{\mathcal{C}} : \functor{\mathcal{C}}{\mathcal{C}}$.
	\item For $F : \functor{\mathcal{C}_1}{\mathcal{C}_2}$ and $G : \functor{\mathcal{C}_2}{\mathcal{C}_3}$, we have a composition $\compf{F}{G} : \functor{\mathcal{C}_1}{\mathcal{C}_2}$;
	\item If $\mathcal{D}$ has binary products, then for $F, G : \functor{\mathcal{C}}{\mathcal{D}}$, we have a product $\prodf{F}{G} : \functor{\mathcal{C}}{\mathcal{D}}$;
	\item If $\mathcal{D}$ has binary sum, then for $F, G : \functor{\mathcal{C}}{\mathcal{D}}$, we have a sum $\sumf{F}{G} : \functor{\mathcal{C}}{\mathcal{D}}$;
	\item For each object $X : \mathcal{D}$, we have a constant functor $\Cf{X} : \functor{\mathcal{C}}{\mathcal{D}}$.
\end{itemize}
\end{notation}

\begin{notation}
\label{def:nattrans}
We have the following transformations.
\begin{itemize}
	\item Given $F, G : \functor{\mathcal{C}}{\mathcal{D}}$, we have
	\[
	\inlt : \nattrans{F}{\sumf{F}{G}}
	\quad \quad
	\inrt : \nattrans{G}{\sumf{F}{G}}
	\quad \quad
	\prlt : \nattrans{\prodf{F}{G}}{F}
	\quad \quad
	\prrt : \nattrans{\prodf{F}{G}}{G}
	\]
	\item Given two transformations $\eta_1 : \nattrans{\compf{F}{G_1}}{\compf{F}{G_2}}$ and $\eta_2 : \nattrans{\compf{F}{G_1}}{\compf{F}{G_3}}$, we have a pairing 
	\[
	\pairt{\eta_1}{\eta_2} : \nattrans{\compf{F}{G_1}}{\compf{F}{\prodf{G_2}{G_3}}}.
	\]
	\item Given functors $F : \functor{\mathcal{C}_1}{\mathcal{C}_2}$ and $G_1. G_2 : \functor{\mathcal{C}_2}{\mathcal{C}_3}$, and a transformation $\eta : \nattrans{G_1}{G_2}$, we have
	\[
	\lwhisker{F}{\eta} : \nattrans{\compf{F}{G_1}}{\compf{F}{G_2}}
	\]
	\item Given a functor $F : \functor{\mathcal{C}}{\hset}$, a set $X : \hset$, and $x : X$, we have a transformation $\ctrans{x} : \nattrans{F}{\Cf{X}}$
\end{itemize}
\end{notation}

\section{Signature of HITs}
\label{sec:signature}
Before we study the construction of set truncated HITs, we first give a precise definition of those.
We do this by internalizing the scheme by Basold \etal \ \cite{BasoldGW17} via a type of signatures.
In this section, we give the definition of signatures, and then in the upcoming sections, we define the notion of HITs for a signature.

Higher inductive types are freely generated by both point and path constructors.
The data of the point constructor is a \emph{polynomial functor}.
These are described by the following type.

\begin{definition}
\label{def:poly}
The type $\mathcal{\poly}$ of \emph{codes of polynomials} is inductively generated by the following constructors.
\begin{center}
\begin{bprooftree}
\AxiomC{$X : \hset$}
\UnaryInfC{$\C \> X : \poly$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$\I : \poly$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$P : \poly$}
\AxiomC{$Q : \poly$}
\BinaryInfC{$\sumP{P}{Q} : \poly$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$P : \poly$}
\AxiomC{$Q : \poly$}
\BinaryInfC{$\prodP{P}{Q} : \poly$}
\end{bprooftree}
\end{center}
\end{definition}

In the next section, we show that each code $P : \poly$ gives rise to a functor $\semP{P} : \functor{\hset}{\hset}$.
A higher inductive type $H$ should have a constructor $\semP{P} \> H \rightarrow H$, which represents the introduction rule for points.

HITs also have an introduction rule for paths, and for those, we need to give the possible endpoints of paths.
Note that in the equations the point constructor can be used, and thus the type of endpoint must depend on the data of the point constructor.
Since each equation is universally quantified, we also have to indicate the source of the arguments, which again depends polynomially on the HIT being defined.
In addition, we allow each equation to have a target also depending polynomially on the HIT.
We define the type of endpoints again as an inductive type.

\begin{definition}
\label{def:endpoint}
Given polynomials, $A, P, Q : \poly$, the type $\ep{A}{P}{Q}$ of \emph{endpoints} is inductively generated by the following constructors.
\begin{center}
\begin{bprooftree}
\AxiomC{$P : \poly$}
\UnaryInfC{$\id{A} : \ep{A}{P}{P}$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$P, Q, R : \poly$}
\AxiomC{$e_1 : \ep{A}{P}{Q}$}
\AxiomC{$e_2 : \ep{A}{Q}{R}$}
\TrinaryInfC{$\comp{e_1}{e_2} : \ep{A}{P}{R}$}
\end{bprooftree}
\end{center}
\begin{center}
\begin{bprooftree}
\AxiomC{$P, Q : \poly$}
\UnaryInfC{$\inle : \ep{A}{P}{\sumP{P}{Q}}$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$P, Q : \poly$}
\UnaryInfC{$\inre : \ep{A}{Q}{\sumP{P}{Q}}$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$P, Q : \poly$}
\UnaryInfC{$\prle : \ep{A}{\prodP{P}{Q}}{P}$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$P, Q : \poly$}
\UnaryInfC{$\prre : \ep{A}{\prodP{P}{Q}}{Q}$}
\end{bprooftree}
\end{center}
\begin{center}
\begin{bprooftree}
\AxiomC{$\constr : \ep{A}{A}{\I}$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$P : \poly$}
\AxiomC{$X : \hset$}
\AxiomC{$x : X$}
\TrinaryInfC{$\Ce \> x : \ep{A}{P}{\C \> X}$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$P, Q, R: \poly$}
\AxiomC{$e_1 : \ep{A}{P}{Q}$}
\AxiomC{$e_2 : \ep{A}{P}{R}$}
\TrinaryInfC{$\pair{e_1}{e_2} : \ep{A}{P}{\prodP{Q}{R}}$}
\end{bprooftree}
\end{center}
\end{definition}

The polynomial $A$ represents the point constructor and that explains the endpoint $\constr$.
The polynomials $P$ and $Q$ represent the source and target of the equation respectively.
If we have a set $X$ with a map $c : \semP{A} \> X \rightarrow X$, each endpoint $e : \ep{A}{P}{Q}$ gives rise to a natural map $\semP{P} \> X \rightarrow \semP{Q} \> X$ where $\constr$ is interpreted with $c$.
These maps are the left- and right-hand side of  the equations.

Now we put it all together to define signatures of HITs.
Note that we index the path constructors by a type meaning that we could possibly have infinitely many path constructors.

\begin{definition}
\label{def:signature}
A \emph{HIT signature} $\sig$ consists of
\begin{itemize}
	\item A polynomial $\pointc{\sig} : \poly$ representing the point constructor;
	\item A type $\pathI{\sig}$ representing the names of path constructors;
	\item A family $\pathA{\sig} : \pathI{\sig} \rightarrow \poly$ representing the source of the paths;
	\item Maps $\pathlh{\sig}, \pathrh{\sig} : \deprod{j}{\pathA{\sig}}{\ep{\pointc{\sig}}{\pathA{\sig} \> j}{I}}$ representing the left- and right-hand side of the equations.
\end{itemize}
\end{definition}

Briefly, the signature $\sig$ represents the following HIT

\begin{lstlisting}[mathescape=true]
Inductive $H$ :=
| $c$ : $\pointc{\sig} \> H \rightarrow H$
| $p$ : $\deprod{j}{\pathI{\sig}}{\deprod{x}{\pathA{\sig} \> H}{\pathlh{\sig} \> j \> x = \pathrh{\sig} \> j \> x}}$
\end{lstlisting}

To illustrate the possibilities of this definition, we define two examples from the introduction as HIT signatures.
The first one is the integers modulo 2 and the second one is the propositional truncation of a set.

\begin{example}
\label{ex:modsig}
Recall $\modZ$ from the introduction.
We represent it by the signature $\modsig$ defined as follows
\begin{itemize}
	\item $\pointc{\modsig} \Def \sumP{\I}{(\C \> \1)}$;
	\item $\pathI{\modsig} \Def \1$;
	\item $\pathA{\modsig} \Def \I$;
	\item $\pathlh{\modsig} \> j \Def \comp{\comp{\comp{\comp{\id{\I}}{\inle}}{\constr}}{\inle}}{\constr}$;
	\item $\pathrh{\modsig} \> j \Def \id{\I}$;
\end{itemize}
\end{example}

Intuitively, this signature represents a HIT $H$ with operation $H + \1 \rightarrow H$ representing the successor and zero.
Note that the endpoint $\comp{\inle}{\constr}$ takes the successor, so, the equation says that $S(S \> x) = x$ for all $x : X$.
Similarly, one can define signatures for groups or join semi-lattices.
Since signatures can depend on types, we can also define the propositional truncation.

\begin{example}
\label{ex:truncsig}
Let $A$ be a set.
We represent the truncation of a set by the following signature.
\begin{itemize}
	\item $\pointc{\trunc} \Def \C \> A$;
	\item $\pathI{\trunc} \Def \1$;
	\item $\pathA{\trunc} \Def \prodP{\I}{\I}$;
	\item $\pathlh{\trunc} \> j \Def \comp{\id{\prodP{\I}{\I}}}{\prle}$;
	\item $\pathrh{\trunc} \> j \Def \comp{\id{\prodP{\I}{\I}}}{\prre}$;
\end{itemize}
\end{example}
This signature represents a HIT $H$ with a map $A \rightarrow H$ and for which all inhabitants are equal. 

\section{Algebras}
\label{sec:algebras}

\subsection{Algebras in Sets}
Now we know what signatures are, the next goal is to define HITs for signatures.
For that we need to give its introduction, elimination, and computation rules.
In this section, we study the introduction rule of HITs and we do that by defining a category of algebras on a polynomial.
Furthermore, since ultimately we want to construct HITs as quotients, we do not just define algebra in sets, but also in setoids.
Let us start by interpreting polynomials as functors.

\begin{definition}
\label{def:sempoly}
For each $P : \poly$, we define a functor $\semP{P} : \functor{\hset}{\hset}$ as follows
\begin{itemize}
	\item $\semP{\C \> X} \Def \Cf{X}$;
	\item $\semP{\I} \Def \idf{\hset}$;
	\item $\semP{\sumP{P}{Q}} \Def \sumf{\semP{P}}{\semP{Q}}$;
	\item $\semP{\sumP{P}{Q}} \Def \prodf{\semP{P}}{\semP{Q}}$.
\end{itemize}
\end{definition}

We write $\falg{F}$ for the category of algebras on the functor $F : \functor{\mathcal{C}}{\mathcal{C}}$.
Its objects are pairs $X : \mathcal{C}$ together with an arrow $\mathcal{C}_1(F \> X, X)$.
Note that we always have a forgetful functor $\forget{F} : \functor{\falg{F}}{\mathcal{C}}$.

Now we define the category $\prealg{\sig}$ to be $\falg{\semP{\pointc{\sig}}}$.
Since the objects do not satisfy the equations in $\sig$, we call this the category of \emph{prealgebras}.
To obtain actual algebras of $\sig$, we need to interpret the equations and for that, we first need to interpret endpoints.
These are interpreted as natural transformations, which are constructed using the transformations from \Cref{sec:prelim}.
Beside those, we use for each polynomial $P$ the transformation $\constrt{P} : \nattrans{\comp{\forget{P}}{\semP{P}}}{\comp{\forget{P}}{\semP{\I}}}$ whose  components are given by the prealgebra map.

\begin{definition}
\label{def:semendpoint}
For each endpoint $e : \ep{A}{P}{Q}$, we define a natural transformation $\semE{e} : \nattrans{\compf{\forget{A}}{\semP{P}}} {\compf{\forget{A}}{\semP{Q}}}$
\begin{itemize}
	\item $\semE{\id{P}} \Def \idt{\compf{\forget{A}}{\semP{P}}}$;
	\item $\semE{\comp{e_1}{e_2}} \Def \compt{\semE{e_1}}{\semE{e_2}}$;
	\item $\semE{\inle} \Def \lwhisker{\forget{A}}{\inlt}$;
	\item $\semE{\inre} \Def \lwhisker{\forget{A}}{\inrt}$;
	\item $\semE{\prle} \Def \lwhisker{\forget{A}}{\prlt}$;
	\item $\semE{\prre} \Def \lwhisker{\forget{A}}{\prrt}$;
	\item $\semE{\pair{e_1}{e_2}} \Def \pairt{\semE{e_1}}{\semE{e_2}}$;
	\item $\semE{\Ce \> t} \Def \ctrans{t}$;
	\item $\semE{\constr} \Def \constrt{A}$.
\end{itemize}
\end{definition}

Now we have everything in place to define algebras on $\sig$.
An algebra on $\sig$ consists of a carrier together with an operation which satisfies the equations specified by $\sig$.
For the operation, we use $\prealg{\pointc{\sig}}$.
Since the carrier of each prealgebra is a set, the equations form a proposition.
Hence, we define the category of \emph{$\sig$-algebras} as a full subcategory of $\prealg{\pointc{\sig}}$.

\begin{definition}
\label{def:algebra}
Let $\sig$ be a HIT signature.
Then we define the category $\Alg{\sig}$ of \emph{$\sig$-algebras} as the full subcategory of $\prealg{\pointc{\sig}}$ such that each object $X$ satisfies
\[
\deprod{j}{\pathI{\sig}}{\deprod{x}{\semP{\pathA{\sig} \> j} \> X}{\semE{\pathlh{\sig} \> j} \> X \> x = \semE{\pathrh{\sig} \> j} \> X \> x}}.
\]
\end{definition}

For an algebra $X$, we denote its operation by $\constrA{X} : \semP{\pointc{\sig}} \> X \rightarrow X$.
The path witnessing the equalities of the algebra is denoted by $\constrP{X} : \deprod{j}{\pathI{\sig}}{\deprod{x}{\semP{\pathA{\sig} \> j} \> X}{\semE{\pathlh{\sig} \> j} \> x = \semE{\pathrh{\sig} \> j} \> x}}$.
Note that the category of $\sig$-algebras is univalent.
This follows from the fact that the category of algebras on a functor is univalent and that univalence is preserved under taking full subcategories.

\begin{proposition}
\label{prop:univalg}
The category of $\sig$-algebras is univalent.
\end{proposition}

Before we look at algebras in setoids in more detail, we recall the examples in the previous section and look what algebras on those signatures are.

\begin{example}
\label{ex:commalg}
Recall the signature $\modsig$ from Example \ref{ex:modsig}.
A prealgebra of $\modsig$ consists of a set $X$ and a map $f : X + \1 \rightarrow X$.
We define $S_X \> x \Def f(\inl \> x)$ and $Z_X = f(\inr \> \TT)$.
An algebra of $\modsig$ consists of a prealgebra $X$ such that for all $x : X \times X$, we have $S_X(S_X \> x) = x$.
\end{example}

\begin{example}
\label{ex:truncalg}
Recall $\trunc$ from Example \ref{ex:truncsig}.
For a set $A$. an algebra of $\trunc \> A$ consists of a set $X$ and a map $f : A \rightarrow X$ such that for all $(x , y) : X \times X$, we have $x = y$.
In particular, this means $X$ is a proposition.
\end{example}

\subsection{Algebras in Setoids}
Recall that the core idea is that we define the initial algebra in sets by taking the quotient of the initial algebra in setoids.
For that reason, we also define algebras in setoids and for these, we take a slightly different approach.
Instead of defining the interpretation of the polynomial $P$ inductively making use of binary sums and products in $\setoids$, we define an equivalence relation on $\semP{P}$.

To define the action of polynomials on equivalence relations, we need some preliminary operations.
For a set $T$, we have an equivalence relation $\pathR{T}$ on $T$ such that $\pathR{T} \> x \> y = (x = y)$.
Furthermore, given types $X$ and $Y$ with equivalence relations $R_X$ and $R_Y$ on them, we can define equivalence relations $\sumR{R_X}{R_Y}$ and $\prodR{R_X}{R_Y}$ on $X + Y$ and $X \times Y$ respectively.
These are defined as follows
\[
\prodR{R_X}{R_Y} \> (x_1,y_1) \> (x_2,y_2) \Def (R_X \> x_1 \> x_2) \times (R_Y \> y_1 \> y_2)
\]
\[
\begin{array}{ccc}
\sumR{R_X}{R_Y} \> (\inl \> x_1) \> (\inl \> x_2) \Def R_X \> x_1 \> x_2 & \quad & \sumR{R_X}{R_Y} \> (\inr \> y_1) \> (\inr \> y_2) \Def R_Y \> y_1 \> y_2\\
\sumR{R_X}{R_Y} \> (\inl \> x) \> (\inr \> y) \Def \0 & \quad & \sumR{R_X}{R_Y} \> (\inr \> y) \> (\inl \> x) \Def \0\\ 
\end{array}
\]

\begin{definition}
Let $R$ be an equivalence relation on a set $X$ and let $P : \poly$ be a polynomial.
By induction, we define an equivalence relation $\polyR{P}{R}$ on $\semP{P} \> X$.
\begin{itemize}
	\item $\polyR{(\C \> T)}{R} \Def \pathR{T}$;
	\item $\polyR{\I}{R} \Def R$;
	\item $\polyR{(\sumP{P}{Q})}{R} \Def \sumR{(\polyR{P}{R})}{(\polyR{Q}{R})}$;
	\item $\polyR{(\prodP{P}{Q})}{R} \Def \prodR{(\polyR{P}{R})}{(\polyR{Q}{R})}$.
\end{itemize}
Now we define the functor $\semPT{P} : \functor{\setoids}{\setoids}$ by $\semPT{P}(X,R) = (\semP{P} \> X, \polyR{P}{R})$.
\end{definition}

Again this gives rise to a category $\prealgst{\sig}$ of \emph{setoid prealgebras on $\sig$}.
To define algebras on $\sig$, we also need to interpret endpoints.
However, these are just setoid morphisms instead of natural transformations.

\begin{definition}
Let $e : \ep{A}{P}{Q}$ be an endpoint and let $X$ be a setoid prealgebra on $A$.
Then we define $\semET{e}$ to be the setoid morphism from $\semE{P}(X)$ to $\semE{Q}(X)$ whose carrier is $\semP{e}$.
\end{definition}

The category of algebras on $\sig$ is defined differently for setoids than for sets.
While for sets, the equations of algebras are witnessed by actual equalities, but for setoids, the equations are witnessed by the equivalence relation.
Note that such relations are families of propositions meaning again this gives rise to a proposition and thus we define it as a full subcategory.

\begin{definition}
Let $\sig$ be a HIT signature.
Then we define the category of \emph{$\sig$-setoid-algebras} as the full subcategory of $\prealgst{\pointc{\sig}}$ such that each object satisfies
\[
\deprod{j}{\pathI{\sig}}{\deprod{x}{\pathA{\sig} \> j}{\semE{\pathlh{\sig} \> j} \> x \equiv \semE{\pathrh{\sig} \> j} \> x}}
\]
where $\equiv$  is the setoid relation.
\end{definition}

Since the category of setoids is univalent, the category of $\sig$-setoid-algebras is univalent as well.

\begin{proposition}
The category of $\sig$-setoid-algebras is unvialent.
\end{proposition}

\section{The Induction Principle}
\label{sec:induction}
The introduction rules of higher inductive types are covered by the algebra structure, but the elimination and computation rules require additional structure.
The main feature of the elimination rule is that it allows defining dependent ``homomorphisms'' to families with some kind of ``dependent algebra structures'' and the computation rule says the algebraic structure is preserved.
To formulate these two rules, we make use of \emph{displayed algebras}, which represent the input of the elimination rule.
When we have all this machinery in place, we define the notion of \emph{higher inductive type} for a signature.

Since our goal is to construct HITs, we need to verify the induction rule and for that, we use initial algebra semantics.
More specifically, we show that the initial algebra satisfies the induction rule.
Hence, to obtain a HIT, it suffices to construct the initial algebra, for which we use category theory.

\subsection{Displayed Algebras}
\label{ref:induction}
A displayed algebra is the input of the elimination rule.
This means that we have a dependent family and a dependent map over the point constructor.
Furthermore, dependent versions of the equations in the signature need to hold.
Displayed algebras are similar to displayed categories \cite{AhrensL19}.

To formulate these requirements precisely, we need two preliminary definitions.
The first one is the action of polynomials on families of sets while the second one interprets endpoints as dependent maps.

\begin{definition}
Given are a polynomial $P$ and a family $Y : X \rightarrow \hset$.
We define a family $\polydact{P}{Y} : \semP{P} \> X \rightarrow \hset$ by induction
\begin{itemize}
	\item $\polydact{\C \> X}{Y} \> x \Def X$;
	\item $\polydact{\I}{Y} \> x \Def Y \> x$;
	\item $\polydact{\sumP{P}{Q}}{Y} \> (\inl \> x) \Def \polydact{P}{Y} \> x$;
	\item $\polydact{\sumP{P}{Q}}{Y} \> (\inr \> x) \Def \polydact{Q}{Y} \> x$;
	\item $\polydact{\prodP{P}{Q}}{Y} \> x \Def \polydact{P}{Y} \> (\prl \> x) \times \polydact{Q}{Y} \> (\prr \> x)$.
\end{itemize}
\end{definition}

\begin{definition}
Let $A$ be a polynomial, $X$ be a prealgebra on $A$, and let $e : \ep{A}{P}{Q}$.
Suppose, we have a family $Y$ on $X$ and a map $c : \deprod{z}{\semP{A}{X}}{\polydact{P}{Y} \> z \rightarrow Y \> (\constrA{X} \> z)}$.
We define a map $\epdact{e}{c} : \deprod{z}{\semP{P}{X}}{\polydact{P}{Y} \> z \rightarrow \polydact{Q}{Y} \> (\semE{e} \> z)}$ by induction on $e$
\begin{itemize}
	\item $\epdact{\id{P}}{c} \> z \> y \Def y$;
	\item $\epdact{\comp{e_1}{e_2}}{c} \> z \> y \Def \epdact{e_2}{c} \> (\semE{e} \> X \> z) \> (\epdact{e_1}{c} \> z \> y)$;
	\item $\epdact{\inle}{c} \> z \> y \Def y$;
	\item $\epdact{\inre}{c} \> z \> y \Def y$;
	\item $\epdact{\prle}{c} \> z \> y \Def \prlt \> y$;
	\item $\epdact{\prre}{c} \> z \> y \Def \prrt \> y$;
	\item $\epdact{\pair{e_1}{e_2}}{c} \> z \> y \Def (\epdact{e_1}{c} \> z \> y , \epdact{e_2}{c} \> z \> y)$;
	\item $\epdact{\Ce \> t}{c} \> z \> y \Def t$;
	\item $\epdact{\constr}{c} \Def c$.
\end{itemize}
\end{definition}

With this in place, we define displayed algebras.
Note that since we are working in a family of sets, we need to use the dependent equality type from Definition \ref{def:depeq} instead.

\begin{definition}
Let $\sig$ be a HIT signature and let $X$ be an algebra on $\sigma$.
Then a \emph{displayed algebra} over $X$ consists of
\begin{itemize}
	\item A type family $Y : X \rightarrow \hset$;
	\item An operation $c_Y : \deprod{z}{\semP{A}{X}}{\polydact{P}{Y} \> z \rightarrow Y \> (\constrA{X} \> z)}$;
	\item For each $j : \pathI{\sig}$, $x : \semP{\pathA{\sig}} \> X$, and $y : \polydact{\pathA{\sig}}{Y} \> x$,  a path $p_Y : \depeq{\constrP{X} \> j \> x}{\epdact{\pathlh{\sig}}{c} \> x \> y}{\epdact{\pathrh{\sig}}{c} \> x \> y}$.
\end{itemize} 
\end{definition}

Now we got the input for the elimination rule in place and the next step is to look at the output.
This is a dependent map which preserves the algebra structure.
To state this preservation property, we need yet another operation on polynomials.

\begin{definition}
Let $P$ be a polynomial, let $X$ be a set, and let $Y$ be a family of sets on $X$.
Given a map $f : \deprod{x}{X}{Y \> x}$, we define a map $\polydmap{P}{f} : \deprod{x}{\semP{P} \> X}{\polydact{P}{Y} \> x}$ by induction
\begin{itemize}
	\item $\polydmap{\C \> X}{f} \> x \Def x$;
	\item $\polydmap{\I}{f} \Def f$;
	\item $\polydmap{\sumP{P}{Q}}{f} \> (\inl \> x) \Def \polydmap{P}{f} \> x$;
	\item $\polydmap{\sumP{P}{Q}}{f} \> (\inr \> x) \Def \polydmap{Q}{f} \> x$;
	\item $\polydmap{\prodP{P}{Q}}{f} \> x \Def (\polydact{P}{f} \> (\prl \> x) , \polydact{Q}{f} \> (\prr \> x))$.
\end{itemize}
\end{definition}

\begin{definition}
Let $Y$ be a displayed algebra over $X$.
Then a displayed algebra map to $Y$ consists of a map $f : \deprod{x}{X}{Y \> x}$ such that for each $x : \semP{\pointc{\sig}}{X}$, we have $f(\constrA{X} \> x) = c_Y \> x \> (\polydmap{\pointc{\sig}}{f} \> x)$.
\end{definition}

With all this in place, we can define the notion of a \emph{higher inductive type} on a signature.
Note that a HIT needs to be an algebra so that we have the correct introduction rules and note that we use displayed algebras to formulate the elimination principle.

\begin{definition}
Let $\sig$ be a HIT signature.
A \emph{higher inductive type} on $\sig$ consists of an algebra $H$ such that for each displayed algebra $Y$ on $H$, we have a displayed algebra map to $Y$.
\end{definition}

\subsection{Obtaining Induction from Initiality}
The goal of this section is to obtain the induction principle from initiality.
This way it suffices construct an initial object of the signature to obtain a HIT.
To this end, we first define the total algebra $\total{Y}$ of a displayed $Y$ on $X$ together a projection $\proj{Y}$ to $X$.
Then we show that induction can be obtained by finding a section of the projection.
Since this is always possible if $X$ is initial, we conclude by saying that initial objects satisfy the induction principle.

We define the carrier of $\total{Y}$ by the dependent sum $\desum{x}{X}{Y \> x}$ and for brevity, we denote this by $\total{Y}$.
To show this is an algebra, we first need to define a map $c_{\total{Y}} : \semP{\pointc{\sig}} \> (\total{Y}) \rightarrow \total{Y}$.
The main idea is that we use the algebra map of $X$ for the first component and the algebra map of $Y$ for the second one.
We introduce an intermediate definition, which allows us to access the right data.

\begin{definition}
Let $P$ be a polynomial and let $Y$ be a family of sets on $X$.
We define a map
\[
\Ppl{P} : \semP{P} \> (\desum{x}{X}{Y \> x} \rightarrow X)
\quad \quad
\Ppl{P} \> x \Def \semP{\pointc{\sig}} \> \prl \> x
\]
We also define a map $\Ppr{P} : \deprod{x}{\semP{P} \> (\desum{x}{X}{Y \> x})}{\polydact{P}{Y} \> (\Ppl{P} \> x)}$ by induction on $P$.
\begin{itemize}
	\item $\Ppr{\C \> T} \> x  \Def x$;
	\item $\Ppr{\I} \> x \Def \prr \> x$;
	\item $\Ppr{\sumP{P}{Q}} \> (\inl x) \Def \Ppr{P} \> x$;
	\item $\Ppr{\sumP{P}{Q}} \> (\inr x) \Def \Ppr{Q} \> x$;
	\item $\Ppr{\prodP{P}{Q}} \> x \Def (\Ppr{P} \> x , \Ppr{Q} \> (\prr \> x))$.
\end{itemize}
\end{definition}

Now let $z : \semP{\pointc{\sig}} \> (\total{Y})$.
The first coordinate of $c_{\total{Y}} \> z$ is defined to be $\constrA{X}(\Ppl{P} \> x)$.
The second coordinate of $c_{\total{Y}} \> z$ is defined by $c_Y \> (\Ppl{P} \> x) \> (\Ppr{P} \> x)$.
The main challenge lies within proving the equations.
To do so, we compute the valuation of endpoints in the total algebra via those in $X$ and $Y$.

\begin{lemma}
For every endpoint $e : \ep{\pointc{\sig}}{P}{Q}$, we have
\[
\Epl : \semE{e} \> X \> (\Ppl{P} \> x) = \Ppl{Q}(\semE{e} \> (\total{Y}) \> x) 
\]
\[
\Epr : \epdact{e}{c_Y} \> (\Ppr{P} \> x) = \transport{\polydact{Q}{Y}}{\invP{\Epl}} \> (\Ppr{Q} \> (\semE{e} \> (\total{Y}) \> x))
\]
\end{lemma}

All in all, given a displayed algebra $Y$ on some algebra $X$, we get the \emph{total algebra} $\total{Y}$.
We also define an algebra homomorphism $\proj{Y} : \total{Y} \rightarrow X$, which sends $z$ to its first projection $\prl \> z$.
The reason why we care about this construction, is the following proposition.

\begin{proposition}
From an algebra homomorphism $f : X \rightarrow \total{Y}$ such that $\compm{f}{\proj{Y}}$ is the identity, we obtain a displayed algebra map from $X$ to $Y$.
\end{proposition}

Now suppose $X$ is an initial object in the category of algebras.
Then, due to initiality, we always have a map $f : X \rightarrow \total{Y}$, and the composition $\comp{f}{\proj{Y}} : X \rightarrow X$ must be the identity because initiality ensures uniqueness of homomorphisms from $X$ to $X$.
Hence, we conclude

\begin{corollary}
If $X$ is an initial object in the category of algebras on $\sig$, then $X$ is a HIT for $\sig$.
\end{corollary}

\section{Constructing the Initial Algebra}
\label{sec:construction}
To construct the initial algebra, we first define a left adjoint from algebras in setoids to algebras in algebras.
Such functors preserve initial objects, and thus it suffices to construct the initial setoid algebra.
For that, we use an adaption of Dybjer's and Moeneclaey's interpretation of HITs in the setoid model \cite{DybjerM18,moeneclaey2016schema}.
In the remainder of this section, we work with a fixed signature $\sig$.

\subsection{Quotient Adjunction}
We start by defining a left adjoint functor $\quotF : \functor{\setoids}{\hset}$.
On objects, we define $\quotF \> (X , R) = \setquot{X}{R}$ and its action on morphisms is defined by recursion on the quotient type.
The laws are proven by quotient induction.
The right adjoint is the path setoid functor $\pathF : \functor{\hset}{\setoids}$.
For sets $X$, we define functor $\pathF \> X$ to be $(X, =_X)$ where $=_X$ is the equivalence relation on $X$ defined by $\lambda x y, x = y$.
Note that this action is functorial and that this gives rise to an adjunction.

\begin{lemma}[Theorem 2.20 from \cite{RijkeS15}]
We have an adjunction $\adj{\quotF}{\pathF}$.
\end{lemma}

\subsection{The Adjunction on Prealgebras}
With this adjunction in place, our first step is to lift it to the level of prealgebras.
The first step, is to lift the functors for which we use the following lemma.

\begin{lemma}
\label{lem:prealgadj}
Given are categories $\mathcal{C}$ and $\mathcal{D}$, functors $A_1 : \functor{\mathcal{C}}{\mathcal{C}}$, $A_2 : \functor{\mathcal{D}}{\mathcal{D}}$, and $F : \functor{\mathcal{C}}{\mathcal{D}}$, and a natural transformation $n : \nattrans{\compf{F}{A_2}}{\compf{A_1}{F}}$.
Then we get a functor $F^{\category{PreAlg}} : \functor{\falg{A_1}}{\falg{A_2}}$.
\end{lemma}

For algebras $(X, f) : \falg{A_1}$, we define $F^{\category{PreAlg}}(X,f) = (F \> X, \compm{F \> f}{n \> X})$.

\begin{lemma}
\label{lem:comm}
We have
\begin{itemize}
	\item $\pathF$ commutes with sums and products.
	\item $\quotF$ commutes with sums and products.
\end{itemize}
This gives rise to two natural isomorphisms $n_1 : \nattrans{\compf{\pathF}{\semPT{\pointc{\sig}}}}{\compf{\semP{\pointc{\sig}}}{\pathF}}$
\end{lemma}

Now we use Lemmata \ref{lem:prealgadj} and \ref{lem:comm} to lift both the quotient and the path setoid functors and we get
\[
\quotPA : \functor{\prealgst{\sig}}{\prealg{\sig}}
\quad \quad
\pathPA : \functor{\prealg{\sig}}{\prealgst{\sig}}.
\]



\begin{lemma}
We have an adjunction $\adj{\quotPA}{\pathPA}$.
\end{lemma}

\subsection{Algebras}

If $\mathcal{C}$ is a category and $P$ is a family of propositions on $\mathcal{C}$, then we write $\fullsub{\mathcal{C}}{P}$ for the full subcategory of $\mathcal{C}$ in which each object satisfies $P$.
First, we look at way to obtain adjunctions between full subcategories.

\begin{lemma}
Let $\mathcal{C}$ and $\mathcal{D}$ be categories, let $P_1$ and $P_2$ be families of propositions on $\mathcal{C}$ and $\mathcal{D}$ respectively, and suppose we have a functor $F : \functor{\mathcal{C}}{\mathcal{D}}$.
If for each object $x : \mathcal{C}$ we have $P_1 \> x \rightarrow P_2(F \> x)$, then we get a functor $\factorsub{F} : \functor{\fullsub{\mathcal{C}}{P_1}}{\fullsub{\mathcal{D}}{P_2}}$.
\end{lemma}

\begin{proposition}
Let $\mathcal{C}$ and $\mathcal{D}$ be categories, let $P_1$ and $P_2$ be families of propositions on $\mathcal{C}$ and $\mathcal{D}$ respectively, and suppose we have an adjunction $\adj{L}{R}$ with $L : \functor{\mathcal{C}}{\mathcal{D}}$.
If for each object $x : \mathcal{C}$ we have $P_1 \> x \rightarrow P_2(L \> x)$ and for each $y : \mathcal{D}$ we have $P_2 \> x \rightarrow P_1(R \> x)$, then we get an adjunction $\adj{\factorsub{L}}{\factorsub{R}}$.
\end{proposition}

Now we would like to apply this proposition to the adjunction obtained from Lemma \ref{lem:prealgadj}.


\begin{theorem}
\label{thm:algadj}
We have an adjunction $\adj{\quotAA}{\pathAA}$.
\end{theorem}




Now we can lift the quotient and path setoid.
We can verify the conditions and we get

To show this adjunction lifts to an adjunction between algebras, we need to show that they map algebras to algebras.
We only show this for the path setoid

\begin{lemma}
path setoid endpoint
\end{lemma}

\begin{lemma}
Path setoid factors through algebras
\end{lemma}

\subsection{Initial Setoid Algebra}
The initial setoid is constructed in two steps.
First we define its carrier as the initial algebra on $\pointc{\sig}$ and then we define the equivalence relation as the least congruence relation containing the equations in $\sig$ and preserving equality of the point constructor.

\begin{lemma}
The category $\prealg{\pointc{\sig}}$ has an initial object.
\end{lemma}

This follows from Ad\'amek's theorem and the fact that the functors $\semP{P}$ is $\omega$-continuous for each $P$.
We denote the initial object of this category by $(\CRC , f)$.
The carrier of the desired setoid is $\CRC$ meaning that the next step is to define the equivalence relation on $\CRC$.

The main difficulty of defining this relation, is that we also must behave correctly on $\semP{\pointc{\sig}}{\CRC}$, because otherwise, we would not be able to lift $f$ to a setoid morphism.
For that reason, we first define a relation $\CR \> P$ on $\semP{P} \> \CRC$ for each $P : \poly$..

\begin{center}
\begin{bprooftree}
\AxiomC{$x : \semP{P} \> \CRC$}
\UnaryInfC{$\CRrefl \> x : \CR \> P \> x \> x$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$r : \CR \> P \> x \> y$}
\UnaryInfC{$\CRsym \> r : \CR \> P \> y \> x$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$r_1 : \CR \> P \> x \> y$}
\AxiomC{$r_2 : \CR \> P \> y \> z$}
\BinaryInfC{$\CRtrans \> r_1 \> r_2 : \CR \> P \> x \> z$}
\end{bprooftree}
\end{center}
\begin{center}
\begin{bprooftree}
\AxiomC{$r : \CR \> P_1 \> x \> y$}
\UnaryInfC{$\CRinl \> r : \CR \> (\sumP{P_1}{P_2}) \> (\inl \> x) \> (\inl \> y)$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$r : \CR \> P_2 \> x \> y$}
\UnaryInfC{$\CRinr \> r : \CR \> (\sumP{P_1}{P_2}) \> (\inr \> x) \> (\inr \> y)$}
\end{bprooftree}
\end{center}
\begin{center}
\begin{bprooftree}
\AxiomC{$r_1 : \CR \> P_1 \> x_1 \> x_2$}
\AxiomC{$r_2 : \CR \> P_2 \> y_1 \> y_2$}
\BinaryInfC{$\CRpair \> r_1 \> r_2 : \CR \> (\prodP{P_1}{P_2}) \> (x_1 , x_2) \> (y_1 , y_2)$}
\end{bprooftree}
\end{center}
\begin{center}
\begin{bprooftree}
\AxiomC{$j : \pathI{\sig}$}
\AxiomC{$x : \semP{\pathA{\sig} \> j} \> \CRC$}
\BinaryInfC{$\CRpath \> j \> x : \CR \> (\semE{\pathlh{\sig} \> j} \> \CRC \> x) \> (\semE{\pathrh{\sig} \> j} \> \CRC \> x)$}
\end{bprooftree}
\begin{bprooftree}
\AxiomC{$r : \CR \> (\pointc{\sig}) \> x \> y$}
\UnaryInfC{$\CRcong \> r : \CR \> \I \> (f \> x) \> (f \> y)$}
\end{bprooftree}
\end{center}

Now we define a relation on $\CRC$ by $\CRR \> x \> y = \trunct{\CR \> \I \> x \> y}$.
Because of the truncation, it takes value in proposition.
Note that $\CRR$ is an equivalence relation, because of the constructor $\CRrefl$, $\CRsym$, and $\CRtrans$.
In addition, all equations in $\sig$ are identified in $\CRR$, because of the constructor $\CRpath$.
Lastly, with the constructors $\CRinl$, $\CRinr$, and $\CRcong$, we can show that $\CRR$ preserves $f$.
Hence, we obtain a setoid $I \Def (\CR, \CRC)$ together with a setoid morphism $\varphi : \semPT{P} \> I \rightarrow I$.
To show that this is the initial setoid, we first need a property of $\CRR$, which allows us to make maps from $I$ to algebras.

\begin{lemma}
\label{lem:mapcongrel}
If $g$ is a prealgebra morphism from $\CR$ to some algebra $X$, then $g$ preserves $\CRR$.
\end{lemma}

Now we show that $I$ is an initial object in $\Alg{\sig}$.
To show that we always have a homomorphism from $I$ to an algebra $X$, we use that $\CR$ is the initial prealgebra and lemma \ref{lem:mapcongrel}.
Furthermore, note that two setoid morphisms are equal if their underlying carriers are equal and two algebra morphisms are also equal if their underlying carrier is equal.
Hence, the uniqueness also follows from initiality of $\CR$.
All in all, we get

\begin{theorem}
\label{thm:initialsetoid}
The category $\Algst{\sig}$ has an initial object.
\end{theorem}

From Theorems \ref{thm:algadj} and \ref{thm:initialsetoid} we conclude

\begin{corollary}
\label{thm:hit-exist}
For each signature $\sig$, we can construct a HIT on $\sig$.
\end{corollary}

\section{Consequences}
\label{sec:consequences}
\subsection{Uniqueness of HITs}
A first property of higher inductive types, is that they are unique up to equality.
For that, we first show that higher inductives are initial algebras.
Note that in \Cref{sec:induction} we made use of the converse statement, namely that initial algebras are HITs.

To show a HIT $H$ is initial, we must show that for each algebra $X$ the set of morphisms from $H$ to $X$ is contractible.
This means that there is precisely one homomorphism from $H$ to $X$.
To show the existence, we use the following two lemmata.

\begin{lemma}
Let $X$ and $Y$ be algebras on $\sig$.
Then there is a displayed algebra $\constdisp{Y}$ on $X$ of which the underlying type family is $Y$ on each point of $X$.
\end{lemma}

\begin{lemma}
Let $X$ be $Y$ be algebras on $\sig$.
If we have a displayed algebra map from $X$ to $\constdisp{Y}$, then we have an algebra homomorphism from $X$ to $Y$.
\end{lemma}

\begin{corollary}
If $X$ is a HIT for $\sig$, then for each algebra $Y$ we have an algebra map from $X$ to $Y$.
\end{corollary}

To show uniqueness, we use an alternative induction principle for families of propositions.
More specifically, we use the following lemma.

\begin{lemma}
Let $H$ be a HIT of $\sig$ and suppose $Y$ is a family of propositions on $H$.
If we have an operation
\[
c : \deprod{z}{\semP{A}{X}}{\polydact{P}{Y} \> z \rightarrow Y \> (f \> z)},
\]
then we have a map $\deprod{x}{H}{Y \> x}$.
\end{lemma}

To prove the uniqueness of the map, we use function extensionality and the previous lemma.
This is sufficient to conclude that higher inductive types are initial objects.

\begin{proposition}
If $H$ is a HIT for $\sig$, then $H$ is an initial $\sig$-algebra.
\end{proposition}

Now we take advantage of Proposition \ref{prop:univalg} where we proved that the category of algebras is univalent.
Since initial objects in a univalent category are unique up to equality, we can immediately conclude that HITs are actually unique up to equality.
All in all, we get

\begin{corollary}
\label{cor:hit_unique}
If $H_1$ and $H_2$ are HITs for $\sig$, then the underlying $\sig$-algebras of $H_1$ and $H_2$ are equal.
\end{corollary}

\subsection{Path Spaces of HITs}
The construction of HITs also allows us to characterize the path space up to equivalence.
For this, we first recall the characterization of the path space of the quotient type.

\begin{proposition}[Lemma 10.1.8 from \cite{hottbook}]
Let $X$ be a type and let $R$ be an equivalence relation on $X$.
Then for each $x, y : X$, we have an equivalence $R \> x \> y \weq \classof \> x = \classof \> y$.
\end{proposition}

Now we specialize this theorem to HITs constructed according to Theorem \ref{thm:hit-exist}.
This allows us to conclude that the path space of set truncated HITs is freely generated.

\begin{corollary}
\label{cor:hit_path}
Let $\sig$ be a signature.
Then for each $x, y : \CR$ we have an equivalence $\CRR \> x \> y \weq \classof \> x = \classof \> y$.
\end{corollary}

\section{Conclusion and Further Work}
\label{sec:conclusion}
We showed how to construct finitary set-truncated higher inductive types using the quotient and propositional truncation in Theorem \ref{thm:hit-exist}.
Since truncations and the quotient can be constructed from nonrecursive HITs, this proves that all finitary set-truncated HITs can be constructed from nonrecursive ones.
Besides that, we took advantage of this construction to show uniqueness of HITs in Corollary \ref{cor:hit_unique} and to characterize their path space in Corollary \ref{cor:hit_path}.

For a construction of all finitary HITs, higher path constructors need to be allowed and the HITs need to be interpreted as higher categories instead of sets.
A first step towards that goal, would be adapting this construction to bicategory theory \cite{ahrens2019bicategories,capriotti2017univalent} and constructing higher inductive 1-types using Dybjer's and Moeneclaey's interpretation of such HITs in groupoids \cite{DybjerM18}.
Doing so, would require interpreting the path constructor terms and the path computation rule becomes relevant.
Proving the induction principle from initiality is more difficult then, because equality becomes proof relevant.
In this setting, Corollary \ref{cor:hit_path} is more interesting, because the computation rules of path constructors become nontrivial.

\begin{thebibliography}{10}\label{bibliography}
	
	\bibitem{AltenkirchCDKF18}
	Thorsten Altenkirch, Paolo Capriotti, Gabe Dijkstra, Nicolai Kraus, and
	Fredrik~Nordvall Forsberg, \emph{{Quotient Inductive-Inductive Types}},
	Foundations of Software Science and Computation Structures - 21st
	International Conference, {FOSSACS} 2018, Held as Part of the European Joint
	Conferences on Theory and Practice of Software, {ETAPS} 2018, Thessaloniki,
	Greece, April 14-20, 2018, Proceedings, 2018, pp.~293--310.
	
	\bibitem{AltenkirchDK17}
	Thorsten Altenkirch, Nils~Anders Danielsson, and Nicolai Kraus,
	\emph{{Partiality, Revisited - The Partiality Monad as a Quotient
			Inductive-Inductive Type}}, Foundations of Software Science and Computation
	Structures - 20th International Conference, {FOSSACS} 2017, Held as Part of
	the European Joint Conferences on Theory and Practice of Software, {ETAPS}
	2017, Uppsala, Sweden, April 22-29, 2017, Proceedings, 2017, pp.~534--549.
	
	\bibitem{ahrens2019bicategories}
	Benedikt Ahrens, Dan Frumin, Marco Maggesi, and Niels van~der Weide,
	\emph{{Bicategories in Univalent Foundations}}, arXiv preprint
	arXiv:1903.01152 (2019).
	
	\bibitem{AwodeyGS12}
	Steven Awodey, Nicola Gambino, and Kristina Sojakova, \emph{{Inductive Types in
			Homotopy Type Theory}}, Proceedings of the 27th Annual {IEEE} Symposium on
	Logic in Computer Science, {LICS} 2012, Dubrovnik, Croatia, June 25-28, 2012,
	2012, pp.~95--104.
	
	\bibitem{AngiuliHW17}
	Carlo Angiuli, Robert Harper, and Todd Wilson, \emph{{Computational
			Higher-Dimensional Type Theory}}, Proceedings of the 44th {ACM} {SIGPLAN}
	Symposium on Principles of Programming Languages, {POPL} 2017, Paris, France,
	January 18-20, 2017, 2017, pp.~680--693.
	
	\bibitem{AltenkirchK16}
	Thorsten Altenkirch and Ambrus Kaposi, \emph{{Type Theory in Type Theory using
			Quotient Inductive Types}}, Proceedings of the 43rd Annual {ACM}
	{SIGPLAN-SIGACT} Symposium on Principles of Programming Languages, {POPL}
	2016, St. Petersburg, FL, USA, January 20 - 22, 2016, 2016, pp.~18--29.
	
	\bibitem{AhrensKS15}
	Benedikt Ahrens, Krzysztof Kapulkin, and Michael Shulman, \emph{{Univalent
			Categories and the Rezk Completion}}, Mathematical Structures in Computer
	Science \textbf{25} (2015), no.~5, 1010--1039.
	
	\bibitem{AhrensL19}
	Benedikt Ahrens and Peter~LeFanu Lumsdaine, \emph{{Displayed Categories}},
	Logical Methods in Computer Science \textbf{15} (2019), no.~1.
	
	\bibitem{AngiuliMLH16}
	Carlo Angiuli, Edward Morehouse, Daniel~R. Licata, and Robert Harper,
	\emph{{Homotopical Patch Theory}}, J. Funct. Program. \textbf{26} (2016),
	e18.
	
	\bibitem{BezemCH13}
	Marc Bezem, Thierry Coquand, and Simon Huber, \emph{{A Model of Type Theory in
			Cubical Sets}}, 19th International Conference on Types for Proofs and
	Programs, {TYPES} 2013, April 22-26, 2013, Toulouse, France, 2013,
	pp.~107--128.
	
	\bibitem{BasoldGW17}
	Henning Basold, Herman Geuvers, and Niels van~der Weide, \emph{{Higher
			Inductive Types in Programming}}, J. {UCS} \textbf{23} (2017), no.~1, 63--88.
	
	\bibitem{CohenCHM16}
	Cyril Cohen, Thierry Coquand, Simon Huber, and Anders M{\"{o}}rtberg,
	\emph{{Cubical Type Theory: A Constructive Interpretation of the Univalence
			Axiom}}, CoRR \textbf{abs/1611.02108} (2016).
	
	\bibitem{CavalloH19}
	Evan Cavallo and Robert Harper, \emph{{Higher Inductive Types in Cubical
			Computational Type Theory}}, {PACMPL} \textbf{3} (2019), no.~{POPL},
	1:1--1:27.
	
	\bibitem{CoquandHM18}
	Thierry Coquand, Simon Huber, and Anders M{\"{o}}rtberg, \emph{{On Higher
			Inductive Types in Cubical Type Theory}}, Proceedings of the 33rd Annual
	{ACM/IEEE} Symposium on Logic in Computer Science, {LICS} 2018, Oxford, UK,
	July 09-12, 2018, 2018, pp.~255--264.
	
	\bibitem{capriotti2017univalent}
	Paolo Capriotti and Nicolai Kraus, \emph{{Univalent Higher Categories via
			Complete Semi-Segal Types}}, Proceedings of the ACM on Programming Languages
	\textbf{2} (2017), no.~POPL, 44.
	
	\bibitem{DybjerM18}
	Peter Dybjer and Hugo Moeneclaey, \emph{{Finitary Higher Inductive Types in the
			Groupoid Model}}, Electr. Notes Theor. Comput. Sci. \textbf{336} (2018),
	119--134.
	
	\bibitem{dybjer1994inductive}
	Peter Dybjer, \emph{{Inductive Families}}, Formal aspects of computing
	\textbf{6} (1994), no.~4, 440--465.
	
	\bibitem{FruminGGW18}
	Dan Frumin, Herman Geuvers, L{\'{e}}on Gondelman, and Niels van~der Weide,
	\emph{{Finite Sets in Homotopy Type Theory}}, Proceedings of the 7th {ACM}
	{SIGPLAN} International Conference on Certified Programs and Proofs, {CPP}
	2018, Los Angeles, CA, USA, January 8-9, 2018, 2018, pp.~201--214.
	
	\bibitem{HofmannS94}
	Martin Hofmann and Thomas Streicher, \emph{{The Groupoid Model Refutes
			Uniqueness of Identity Proofs}}, Proceedings of the Ninth Annual Symposium on
	Logic in Computer Science {(LICS} '94), Paris, France, July 4-7, 1994, 1994,
	pp.~208--212.
	
	\bibitem{KaposiK18}
	Ambrus Kaposi and Andr{\'{a}}s Kov{\'{a}}cs, \emph{{A Syntax for Higher
			Inductive-Inductive Types}}, 3rd International Conference on Formal
	Structures for Computation and Deduction, {FSCD} 2018, July 9-12, 2018,
	Oxford, {UK}, 2018, pp.~20:1--20:18.
	
	\bibitem{KaposiKA19}
	Ambrus Kaposi, Andr{\'{a}}s Kov{\'{a}}cs, and Thorsten Altenkirch,
	\emph{{Constructing Quotient Inductive-Inductive Types}}, {PACMPL} \textbf{3}
	(2019), no.~{POPL}, 2:1--2:24.
	
	\bibitem{simpset}
	Chris Kapulkin and Peter~LeFanu Lumsdaine, \emph{{The Simplicial Model of
			Univalent Foundations (after Voevodsky)}}, 2012.
	
	\bibitem{Kraus16}
	Nicolai Kraus, \emph{{Constructions with Non-Recursive Higher Inductive
			Types}}, Proceedings of the 31st Annual {ACM/IEEE} Symposium on Logic in
	Computer Science, {LICS} '16, New York, NY, USA, July 5-8, 2016, 2016,
	pp.~595--604.
	
	\bibitem{KrausRaumer}
	Nicolai Kraus and Jakob von Raumer, \emph{{Path Spaces of Higher Inductive
			Types in Homotopy Type Theory}}, CoRR \textbf{abs/1901.06022} (2019).
	
	\bibitem{LicataF14}
	Daniel~R. Licata and Eric Finster, \emph{{Eilenberg-MacLane Spaces in Homotopy
			Type Theory}}, Joint Meeting of the Twenty-Third {EACSL} Annual Conference on
	Computer Science Logic {(CSL)} and the Twenty-Ninth Annual {ACM/IEEE}
	Symposium on Logic in Computer Science (LICS), {CSL-LICS} '14, Vienna,
	Austria, July 14 - 18, 2014, 2014, pp.~66:1--66:9.
	
	\bibitem{LicataS13}
	Daniel~R. Licata and Michael Shulman, \emph{{Calculating the Fundamental Group
			of the Circle in Homotopy Type Theory}}, 28th Annual {ACM/IEEE} Symposium on
	Logic in Computer Science, {LICS} 2013, New Orleans, LA, USA, June 25-28,
	2013, 2013, pp.~223--232.
	
	\bibitem{lumsdaine2017semantics}
	Peter~LeFanu Lumsdaine and Mike Shulman, \emph{{Semantics of Higher Inductive
			Types}}, arXiv preprint arXiv:1705.07088 (2017).
	
	\bibitem{mac2013categories}
	Saunders Mac~Lane, \emph{{Categories for the Working Mathematician}}, vol.~5,
	Springer Science \& Business Media, 2013.
	
	\bibitem{moeneclaey2016schema}
	H.~Moeneclaey.
	\newblock {A Schema for Higher Inductive Types of Level One and Its
		Interpretation}.
	\newblock {\em Internship report, supervised by Peter Dybjer, ENS
		Paris-Saclay}, 2016.
	
	\bibitem{rijke2017join}
	Egbert Rijke, \emph{{The Join Construction}}, arXiv preprint arXiv:1701.07538
	(2017).
	
	\bibitem{RijkeS15}
	Egbert Rijke and Bas Spitters, \emph{{Sets in Homotopy Type Theory}},
	Mathematical Structures in Computer Science \textbf{25} (2015), no.~5,
	1172--1202.
	
	\bibitem{Sojakova15}
	Kristina Sojakova, \emph{{Higher Inductive Types as Homotopy-Initial
			Algebras}}, Proceedings of the 42nd Annual {ACM} {SIGPLAN-SIGACT} Symposium
	on Principles of Programming Languages, {POPL} 2015, Mumbai, India, January
	15-17, 2015, 2015, pp.~31--42.
	
	\bibitem{hottbook}
	{The Univalent Foundations Program}, \emph{{Homotopy Type Theory: Univalent
			Foundations of Mathematics}}, \url{https://homotopytypetheory.org/book},
	Institute for Advanced Study, 2013.
	
	\bibitem{UniMath}
	Vladimir Voevodsky, Benedikt Ahrens, Daniel Grayson, et~al., \emph{{UniMath ---
			a computer-checked library of univalent mathematics}}, {available} at
	\url{https://github.com/UniMath/UniMath}.
	
	\bibitem{Doorn16}
	Floris van Doorn, \emph{{Constructing the Propositional Truncation using
			Non-Recursive HITs}}, Proceedings of the 5th {ACM} {SIGPLAN} Conference on
	Certified Programs and Proofs, Saint Petersburg, FL, USA, January 20-22,
	2016, 2016, pp.~122--129.	
\end{thebibliography}
\end{document}
